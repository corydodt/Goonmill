#!/bin/bash

# Run twistd goonmill repeatedly, restarting whenever a source file changes.
echo
echo ^C to kill.
echo

killTwistd() {
    if [ -e goonmill.pid ]; then
        PID=`cat goonmill.pid`
        kill $PID
        echo WAITING ON $PID
        wait $PID >/dev/null 2>&1
        echo TWISTD DONE.
    fi
}

# this trap will clean up when someone presses ^C
trap killTwistd EXIT

[ -e ./options.local ] && source ./options.local
twistdOptions=${twistdOptions:--n --pidfile goonmill.pid}
goonmillOptions=${goonmillOptions:---dev}
inotifyOptions=${inotifyOptions:--e modify $(find . -name '*.py')}

safeTty() {
    tty="`tty`"
    if [ "$tty" == "not a tty" ]; then
        tty=/dev/null
    fi
    echo "$tty"
}

while true; do
  killTwistd
  # Python automatically compiles source files; if we let it do that,
  # dnotify will think something has changed as soon as twistd imports the
  # file that changed, and we'll restart twice.
  # To prevent that, compile this directory now before running.
  echo COMPILING
  python -m compileall . >/dev/null 2>&1
  # Redirect stdin from our tty. If you don't do this, interactive pdb
  # doesn't work.
  echo RUNNING
  twistd ${twistdOptions} goonmill ${goonmillOptions} <"`safeTty`" &
  inotifywait ${inotifyOptions}
done
 
